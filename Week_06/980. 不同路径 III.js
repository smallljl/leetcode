/**
 * 
 *  在二维网格 grid 上，有 4 种类型的方格：

    1 表示起始方格。且只有一个起始方格。
    2 表示结束方格，且只有一个结束方格。
    0 表示我们可以走过的空方格。
    -1 表示我们无法跨越的障碍。

    返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目。

    每一个无障碍方格都要通过一次，但是一条路径中不能重复通过同一个方格。

    示例 1：

    输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]
    输出：2
    解释：我们有以下两条路径：
        1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)
        2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)
    示例 2：

    输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]
    输出：4
    解释：我们有以下四条路径： 
        1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)
        2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)
        3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)
        4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)
    示例 3：

    输入：[[0,1],[2,0]]
    输出：0
    解释：
    没有一条路能完全穿过每一个空的方格一次。
    请注意，起始和结束方格可以位于网格中的任意位置。

 * 
 * 
 */

/**
 * @param {number[][]} grid
 * @return {number}
 */
var uniquePathsIII = function(grid) {
    if(!grid.length) return 0;
    let startRow = 0;//起始点的行号
    let startCol = 0;//起始点的列号
    let totalStep = 0;//总共要经过的格子的数量(题中数组里 0 的个数)
    let dx = [0,1,0,-1];
    let dy = [-1,0,1,0];
    //遍历数组，找到起始点并记录其行列
    for(let i = 0; i < grid.length; i++){
      for(let j = 0; j < grid[i].length; j++){
        if(grid[i][j] == 1){
          startRow = i;
          startCol = j;
        }
        if(grid[i][j] == 0) totalStep++; //统计总过要走的格子数
      }
    }
    // 从起始点开始查找
    return dfs(grid,startRow,startCol,totalStep);
  
    /**
     * @param {number[][]} grid
     * @param {number} row
     * @param {number} col
     * @param {number} remainStep 剩下的要走的格子数
     * @return {number}
     */
    // 核心：把走过的路给"沉"了
    function dfs(grid,row,col,remainStep){
        //判断临界情况，超出边界或遇到障碍物，则此路不通
        if(row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] === -1) return 0;
        
        //遇到2则表示遇到终点, 注意，走完所有空白格子再走一步，才能抵达终点，因此判断 remainStep 值为 -1 而不是 0
        if(grid[row][col] == 2) return remainStep === -1 ? 1 : 0; 
        
        grid[row][col] = -1; // 将当前走到的格子设为障碍物
        
        let res = 0; //统计可行的道路数量
        
        //向四周查找能到达终点的路线，累加到 res 上
        for(let i = 0; i < 4; i++){
            res += dfs(grid,row + dy[i], col + dx[i], remainStep - 1); 
        }
        // 当前路线查找完毕，开始下一条路线前，将当前格子还原为 可通行的格子(0)
        grid[row][col] = 0;
        //返回结果
        return res;
    }
};

  